"""
KazoHome.SDK Python Integration Base
Base classes for Home Assistant custom_component integrations

This file is auto-generated by KazoHome.SDK.Bridge
"""

import asyncio
import logging
from abc import ABC, abstractmethod
from typing import Any, Dict, Optional, TYPE_CHECKING

from homeassistant.config_entries import ConfigEntry
from homeassistant.core import HomeAssistant
from homeassistant.helpers.entity import Entity

from .kazohome_bridge import KazoHomeBridge

if TYPE_CHECKING:
    from homeassistant.helpers.entity_platform import AddEntitiesCallback

_LOGGER = logging.getLogger(__name__)


class KazoHomeIntegration(ABC):
    """Base class for KazoHome integrations"""

    def __init__(
        self,
        hass: HomeAssistant,
        entry: ConfigEntry,
        socket_path: str = "/tmp/kazohome_bridge.sock"
    ):
        self.hass = hass
        self.entry = entry
        self.bridge = KazoHomeBridge(socket_path)
        self._platforms: list[str] = []

    @property
    @abstractmethod
    def domain(self) -> str:
        """Return the integration domain"""
        pass

    @property
    def platforms(self) -> list[str]:
        """Return the platforms this integration provides"""
        return self._platforms

    async def async_setup(self) -> bool:
        """Set up the integration"""
        try:
            await self.bridge.connect()
            
            # Notify .NET side that we're starting
            await self.bridge.send_notification("integration.setup", {
                "domain": self.domain,
                "entry_id": self.entry.entry_id,
                "data": dict(self.entry.data)
            })

            # Forward HA events to .NET
            self._setup_event_forwarding()

            return True

        except Exception as ex:
            _LOGGER.error("Failed to setup integration: %s", ex)
            return False

    async def async_unload(self) -> bool:
        """Unload the integration"""
        try:
            await self.bridge.send_notification("integration.unload", {
                "domain": self.domain,
                "entry_id": self.entry.entry_id
            })
            await self.bridge.disconnect()
            return True

        except Exception as ex:
            _LOGGER.error("Failed to unload integration: %s", ex)
            return False

    def _setup_event_forwarding(self) -> None:
        """Set up event forwarding from HA to .NET"""
        
        async def forward_state_change(event) -> None:
            """Forward state change events to .NET"""
            await self.bridge.send_notification("ha.state_changed", {
                "entity_id": event.data.get("entity_id"),
                "old_state": self._serialize_state(event.data.get("old_state")),
                "new_state": self._serialize_state(event.data.get("new_state"))
            })

        self.hass.bus.async_listen("state_changed", forward_state_change)

    def _serialize_state(self, state) -> Optional[Dict[str, Any]]:
        """Serialize a state object for transmission"""
        if state is None:
            return None
        
        return {
            "entity_id": state.entity_id,
            "state": state.state,
            "attributes": dict(state.attributes),
            "last_changed": state.last_changed.isoformat() if state.last_changed else None,
            "last_updated": state.last_updated.isoformat() if state.last_updated else None
        }

    async def call_dotnet_service(
        self,
        service: str,
        data: Optional[Dict[str, Any]] = None
    ) -> Any:
        """Call a service implemented in .NET"""
        return await self.bridge.send_request(f"service.{service}", data or {})


class KazoHomeEntity(Entity):
    """Base class for entities backed by .NET"""

    def __init__(
        self,
        bridge: KazoHomeBridge,
        entity_id: str,
        name: str,
        unique_id: str
    ):
        self._bridge = bridge
        self._entity_id = entity_id
        self._attr_name = name
        self._attr_unique_id = unique_id
        self._state: Optional[str] = None
        self._attributes: Dict[str, Any] = {}

    @property
    def entity_id(self) -> str:
        return self._entity_id

    @property
    def state(self) -> Optional[str]:
        return self._state

    @property
    def extra_state_attributes(self) -> Dict[str, Any]:
        return self._attributes

    async def async_update(self) -> None:
        """Fetch state from .NET"""
        try:
            result = await self._bridge.send_request("entity.get_state", {
                "entity_id": self._entity_id
            })
            if result:
                self._state = result.get("state")
                self._attributes = result.get("attributes", {})
        except Exception as ex:
            _LOGGER.error("Failed to update entity %s: %s", self._entity_id, ex)

    async def async_call_service(
        self,
        service: str,
        data: Optional[Dict[str, Any]] = None
    ) -> None:
        """Call a service on this entity via .NET"""
        await self._bridge.send_request(f"entity.{service}", {
            "entity_id": self._entity_id,
            "data": data or {}
        })
