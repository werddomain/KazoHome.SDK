"""
KazoHome.SDK Python Bridge Proxy
This module provides the bridge between Home Assistant custom_components and .NET

This file is auto-generated by KazoHome.SDK.Bridge
"""

import asyncio
import json
import logging
import socket
from dataclasses import dataclass
from datetime import datetime
from typing import Any, Callable, Dict, Optional
import uuid

_LOGGER = logging.getLogger(__name__)


@dataclass
class BridgeMessage:
    """Message envelope for bridge communication"""
    id: str
    type: str
    method: Optional[str] = None
    payload: Optional[Any] = None
    error: Optional[Dict[str, Any]] = None
    timestamp: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        return {
            "Id": self.id,
            "Type": self.type,
            "Method": self.method,
            "Payload": self.payload,
            "Error": self.error,
            "Timestamp": self.timestamp or datetime.utcnow().isoformat()
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "BridgeMessage":
        return cls(
            id=data.get("Id", ""),
            type=data.get("Type", ""),
            method=data.get("Method"),
            payload=data.get("Payload"),
            error=data.get("Error"),
            timestamp=data.get("Timestamp")
        )


class KazoHomeBridge:
    """Bridge client for communicating with .NET backend"""

    def __init__(self, socket_path: str = "/tmp/kazohome_bridge.sock"):
        self._socket_path = socket_path
        self._reader: Optional[asyncio.StreamReader] = None
        self._writer: Optional[asyncio.StreamWriter] = None
        self._pending_requests: Dict[str, asyncio.Future] = {}
        self._event_handlers: Dict[str, list[Callable]] = {}
        self._receive_task: Optional[asyncio.Task] = None
        self._connected = False

    @property
    def is_connected(self) -> bool:
        return self._connected

    async def connect(self) -> None:
        """Connect to the .NET bridge server"""
        if self._connected:
            _LOGGER.warning("Already connected to bridge")
            return

        try:
            self._reader, self._writer = await asyncio.open_unix_connection(
                self._socket_path
            )
            self._connected = True
            self._receive_task = asyncio.create_task(self._receive_loop())
            _LOGGER.info("Connected to KazoHome bridge at %s", self._socket_path)
        except Exception as ex:
            _LOGGER.error("Failed to connect to bridge: %s", ex)
            raise

    async def disconnect(self) -> None:
        """Disconnect from the .NET bridge server"""
        if not self._connected:
            return

        self._connected = False

        if self._receive_task:
            self._receive_task.cancel()
            try:
                await self._receive_task
            except asyncio.CancelledError:
                pass
            self._receive_task = None

        if self._writer:
            self._writer.close()
            await self._writer.wait_closed()
            self._writer = None
            self._reader = None

        # Cancel pending requests
        for future in self._pending_requests.values():
            future.cancel()
        self._pending_requests.clear()

        _LOGGER.info("Disconnected from KazoHome bridge")

    async def send_request(
        self,
        method: str,
        payload: Any = None,
        timeout: float = 10.0
    ) -> Any:
        """Send a request and wait for response"""
        if not self._connected:
            raise RuntimeError("Not connected to bridge")

        message_id = str(uuid.uuid4())
        message = BridgeMessage(
            id=message_id,
            type="request",
            method=method,
            payload=payload
        )

        future: asyncio.Future = asyncio.get_event_loop().create_future()
        self._pending_requests[message_id] = future

        try:
            await self._send_message(message)
            response = await asyncio.wait_for(future, timeout=timeout)

            if response.error:
                raise BridgeError(
                    response.error.get("Code", "unknown"),
                    response.error.get("Message", "Unknown error")
                )

            return response.payload
        finally:
            self._pending_requests.pop(message_id, None)

    async def send_notification(self, method: str, payload: Any = None) -> None:
        """Send a notification (fire and forget)"""
        if not self._connected:
            raise RuntimeError("Not connected to bridge")

        message = BridgeMessage(
            id=str(uuid.uuid4()),
            type="notification",
            method=method,
            payload=payload
        )
        await self._send_message(message)

    def subscribe_event(self, event_type: str, handler: Callable[[Any], None]) -> None:
        """Subscribe to events from the .NET side"""
        if event_type not in self._event_handlers:
            self._event_handlers[event_type] = []
        self._event_handlers[event_type].append(handler)

    def unsubscribe_event(self, event_type: str, handler: Callable[[Any], None]) -> None:
        """Unsubscribe from events"""
        if event_type in self._event_handlers:
            try:
                self._event_handlers[event_type].remove(handler)
            except ValueError:
                pass

    async def _send_message(self, message: BridgeMessage) -> None:
        """Send a message to the .NET side"""
        if not self._writer:
            raise RuntimeError("Not connected")

        data = json.dumps(message.to_dict()) + "\n"
        self._writer.write(data.encode())
        await self._writer.drain()

    async def _receive_loop(self) -> None:
        """Background task to receive messages"""
        while self._connected and self._reader:
            try:
                line = await self._reader.readline()
                if not line:
                    _LOGGER.warning("Bridge connection closed")
                    break

                data = json.loads(line.decode())
                message = BridgeMessage.from_dict(data)
                await self._handle_message(message)

            except asyncio.CancelledError:
                break
            except json.JSONDecodeError as ex:
                _LOGGER.warning("Failed to decode message: %s", ex)
            except Exception as ex:
                _LOGGER.error("Error in receive loop: %s", ex)
                break

        self._connected = False

    async def _handle_message(self, message: BridgeMessage) -> None:
        """Handle incoming messages"""
        if message.type == "response":
            future = self._pending_requests.get(message.id)
            if future and not future.done():
                future.set_result(message)

        elif message.type == "event":
            handlers = self._event_handlers.get(message.method, [])
            for handler in handlers:
                try:
                    if asyncio.iscoroutinefunction(handler):
                        await handler(message.payload)
                    else:
                        handler(message.payload)
                except Exception as ex:
                    _LOGGER.error("Error in event handler: %s", ex)


class BridgeError(Exception):
    """Exception raised by bridge operations"""

    def __init__(self, code: str, message: str):
        super().__init__(message)
        self.code = code
